devtools::build()
devtools::reload()
source("~/WorkSpace/git/knapsack/R/dynamic.R")
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
dynamic_knapsack(x = knapsack_objects[1:8,], W = 3500)
dynamic_knapsack(x = knapsack_objects[1:8,], W = 3500)
source("~/WorkSpace/git/knapsack/R/dynamic.R")
dynamic_knapsack(x = knapsack_objects[1:8,], W = 3500)
install.packages("profvis")
source("~/WorkSpace/git/knapsack/R/parallel_brute.R")
set.seed(42)
knapsack_objects <- data.frame(
w = sample(1:4000, size = 20, replace = TRUE),
v = runif(20, 0, 10000)
)
# 使用并行计算
result_parallel <- brute_force_knapsack(knapsack_objects, W = 20000, parallel = TRUE)
source("~/WorkSpace/git/knapsack/R/parallel_brute.R")
set.seed(42)
knapsack_objects <- data.frame(
w = sample(1:4000, size = 20, replace = TRUE),
v = runif(20, 0, 10000)
)
# 使用并行计算
result_parallel <- brute_force_knapsack(knapsack_objects, W = 20000, parallel = TRUE)
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(knapsack_objects, W = 20000, parallel = TRUE)
source("~/WorkSpace/git/knapsack/R/parallel_brute.R")
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(knapsack_objects, W = 20000, parallel = TRUE)
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(knapsack_objects, W = 20000, parallel = TRUE)
source("~/WorkSpace/git/knapsack/R/parallel_brute.R")
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(knapsack_objects, W = 20000, parallel = TRUE)
source("~/WorkSpace/git/knapsack/R/parallel_brute.R")
source("~/WorkSpace/git/knapsack/R/parallel_brute.R")
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(knapsack_objects, W = 20000, parallel = TRUE)
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
source("~/WorkSpace/git/knapsack/R/brute.R")
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
source("~/WorkSpace/git/knapsack/R/dynamic.R")
dynamic_knapsack(x = knapsack_objects[1:8,], W = 3500)
source("~/WorkSpace/git/knapsack/R/greed.R")
greedy_knapsack(x = knapsack_objects[1:800,], W = 3500)
devtools::load_all(".")
rm(list = c("brute_force_knapsack", "dynamic_knapsack",
"greedy_knapsack"))
devtools::load_all(".")
source("~/WorkSpace/git/knapsack/R/brute.R")
source("~/WorkSpace/git/knapsack/R/brute.R")
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
source("~/WorkSpace/git/knapsack/R/brute.R")
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
source("~/WorkSpace/git/knapsack/R/brute.R")
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
source("~/WorkSpace/git/knapsack/R/brute.R")
brute_force_knapsack(x = knapsack_objects[1:8,], W = 3500)
brute_force_knapsack(x = knapsack_objects[1:12,], W = 3500)
install.packages("rmarkdown")
install.packages("knitr")
source("~/WorkSpace/git/knapsack/R/brute.R")
brute_force_knapsack(x = knapsack_objects[1:12,], W = 3500)
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
source("~/WorkSpace/git/knapsack/R/dynamic.R")
dynamic_knapsack(x = knapsack_objects[1:12,], W = 2000)
source("~/WorkSpace/git/knapsack/R/greed.R")
#' Solve the Knapsack Problem using Greedy Heuristic
#'
#' This function solves the knapsack problem using a greedy approach.
#' It selects items based on their value-to-weight ratio until the capacity is full.
#'
#' @param x A data frame with two columns: \code{v} for values and \code{w} for weights.
#'          Each row represents an item with a value and a weight.
#' @param W A positive numeric value representing the maximum weight capacity of the knapsack.
#'
#' @return A list with two elements:
#'   \item{value}{The total value of the items selected for the knapsack.}
#'   \item{elements}{The indices of the items in \code{x} that have been selected as numeric values.}
#'
#' @examples
#' set.seed(42)
#' knapsack_objects <- data.frame(
#'   w = sample(1:4000, size = 1200, replace = TRUE),
#'   v = runif(1200, 0, 10000)
#' )
#' greedy_knapsack(x = knapsack_objects, W = 2000)
#'
#' @export
greedy_knapsack <- function(x, W) {
# Input validation
if (!is.data.frame(x) || !all(c("v", "w") %in% names(x))) {
stop("Input must be a data frame with columns 'v' and 'w'.")
}
# Check if knapsack capacity is positive
if (W <= 0) {
stop("Knapsack capacity must be greater than 0.")
}
# Check if values and weights are non-negative
if (any(x$v < 0) || any(x$w < 0) || any(is.na(x$w)) || any(is.na(x$v))) {
stop("Values and weights must not contain NA and must be non-negative.")
}
# Calculate value-to-weight ratio
x$unit_value <- x$v / x$w
# Sort items by value-to-weight ratio in descending order
x <- x[order(-x$unit_value), ]
total_value <- 0  # Initialize total value
total_weight <- 0  # Initialize total weight
selected_items <- integer(0)  # Initialize selected items index
# Select items
for (i in 1:nrow(x)) {
if (total_weight + x$w[i] <= W) {  # If adding the current item doesn't exceed capacity
total_weight <- total_weight + x$w[i]  # Update total weight
total_value <- total_value + x$v[i]  # Update total value
selected_items <- c(selected_items, as.numeric(rownames(x)[i]))  # Record the selected item index
} else {
break  # If adding the current item exceeds capacity, stop selection
}
}
return(list(value = round(total_value), elements = selected_items))  # Return total value and selected item indices
}
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
greedy_knapsack(x = knapsack_objects[1:1200,], W = 2000)
system.time({
greedy_knapsack(x = knapsack_objects[1:1200,], W = 2000)
})
#' Solve the Knapsack Problem using Dynamic Programming
#'
#' This function solves the knapsack problem using dynamic programming.
#' It constructs a table to store the maximum value for each weight capacity.
#' The result is obtained by iterating over all items and weights.
#'
#' @param x A data frame with two columns: \code{v} for values and \code{w} for weights.
#'          Each row represents an item with a value and a weight.
#' @param W A positive numeric value representing the maximum weight capacity of the knapsack.
#'
#' @return A list with two elements:
#'   \item{value}{The maximum total value of the knapsack.}
#'   \item{elements}{The indices of the items in \code{x} that make up the optimal solution.}
#'
#' @examples
#' knapsack_objects <- data.frame(
#'   w = sample(1:4000, size = 8, replace = TRUE),
#'   v = runif(n = 8, 0, 10000)
#' )
#' dynamic_knapsack(knapsack_objects, W = 3500)
#'
#' @export
dynamic_knapsack <- function(x, W) {
# Input validation: Check if x is a data frame with 'v' and 'w' columns
if (!is.data.frame(x) || !all(c("v", "w") %in% names(x))) {
stop("Input must be a data frame with 'v' and 'w' columns.")
}
# Check if W is a positive number
if (W <= 0) {
stop("Knapsack capacity must be greater than 0.")
}
# Ensure all values and weights are non-negative
if (any(x$v < 0) || any(x$w < 0)) {
stop("Values and weights must be non-negative.")
}
n <- nrow(x)  # Get the number of items
# Create a table to store maximum values for each weight capacity
dp <- matrix(0, nrow = n + 1, ncol = W + 1)
# Fill the dp table
for (i in 1:n) {
for (w in 0:W) {
if (x$w[i] <= w) {
dp[i + 1, w] <- max(dp[i, w], dp[i, w - x$w[i]] + x$v[i])
} else {
dp[i + 1, w] <- dp[i, w]
}
}
}
# The maximum value will be in dp[n + 1, W] instead of dp[n + 1, W + 1]
best_value <- dp[n + 1, W]
# Now we need to find which items make up this maximum value
best_combination <- integer(0)
w <- W
for (i in n:1) {
if (dp[i + 1, w] != dp[i, w]) {  # If the values are different, the item was chosen
best_combination <- c(best_combination, i)  # Store the item index
w <- w - x$w[i]  # Reduce the remaining weight of the knapsack
}
}
# Return a list containing the maximum value and the indices of the selected items
return(list(value = best_value, elements = best_combination))
}
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
dynamic_knapsack(x = knapsack_objects[1:12,], W = 2000)
system.time({
dynamic_knapsack(x = knapsack_objects[1:12,], W = 2000)
})
library(profvis)
> set.seed(42)
library(profvis)
> set.seed(42)
library(profvis) set.seed(42)
library(profvis)
set.seed(42)
n <- 2000
knapsack_objects <- data.frame(
+     w = sample(1:4000, size = n, replace = TRUE),
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
profvis({result <- dynamic_knapsack(knapsack_objects, W = 3500)})
source("~/WorkSpace/git/knapsack/R/brute.R")
profvis({result <- brute_force_knapsack(knapsack_objects, W = 3500)})
profvis({result <- brute_force_knapsack(knapsack_objects, W = 3500)})
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
profvis({result <- brute_force_knapsack(knapsack_objects, W = 3500)})
library(profvis)
# 定义 brute_force_knapsack 函数（与之前相同）
# 创建示例数据
set.seed(42)
n <- 20  # 增加物品数量
knapsack_objects <- data.frame(
w = sample(1:4000, size = n, replace = TRUE),
v = runif(n = n, 0, 10000)
)
# 设置背包容量
W <- 10000
# 手动使用 rprof
rprof("prof.out")  # 开始性能分析
library(profvis)
# 定义 brute_force_knapsack 函数（与之前相同）
# 创建示例数据
set.seed(42)
n <- 20  # 增加物品数量
knapsack_objects <- data.frame(
w = sample(1:4000, size = n, replace = TRUE),
v = runif(n = n, 0, 10000)
)
# 设置背包容量
W <- 10000
# 手动使用 rprof
result <- brute_force_knapsack(knapsack_objects, W)
# 使用 profvis 可视化结果
profvis::profvis({
summaryRprof("prof.out")
})
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
#' Solve the Knapsack Problem using Brute Force
#'
#' This function solves the knapsack problem using brute-force search.
#'
#' @param x A data frame with two columns: \code{v} for values and \code{w} for weights.
#' @param W A positive numeric value representing the maximum weight capacity of the knapsack.
#'
#' @return A list with two elements:
#'   \item{value}{The maximum total value of the knapsack.}
#'   \item{elements}{The indices of the items in \code{x} that make up the optimal solution.}
#'
#' @export
brute_force_knapsack <- function(x, W) {
if (!is.data.frame(x) || !all(c("v", "w") %in% names(x))) {
stop("Input must be a data frame with columns 'v' and 'w'.")
}
if (W <= 0) {
stop("Knapsack capacity must be greater than 0.")
}
if (any(x$v < 0) || any(x$w < 0)) {
stop("Values and weights must be non-negative.")
}
n <- nrow(x)
best_value <- 0
best_combination <- NULL
# Brute-force search: Enumerate all possible combinations (2^n)
for (i in 0:(2^n - 1)) {
selected <- as.logical(intToBits(i)[1:n])
total_weight <- sum(x$w[selected])
total_value <- sum(x$v[selected])
if (total_weight <= W && total_value > best_value) {
best_value <- total_value
best_combination <- which(selected)
}
}
return(list(value = best_value, elements = best_combination))
}
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000)
system.time({
brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000)
})
brute_force_knapsack(x = knapsack_objects[1:12,], W = 3500)
library(parallel)
#' Solve the Knapsack Problem using Brute Force
#'
#' This function solves the knapsack problem using brute-force search.
#'
#' @param x A data frame with two columns: \code{v} for values and \code{w} for weights.
#' @param W A positive numeric value representing the maximum weight capacity of the knapsack.
#' @param parallel A logical value indicating whether to use parallel computation. Defaults to FALSE.
#'
#' @return A list with two elements:
#'   \item{value}{The maximum total value of the knapsack.}
#'   \item{elements}{The indices of the items in \code{x} that make up the optimal solution.}
#'
#' @export
brute_force_knapsack <- function(x, W, parallel = FALSE) {
if (!is.data.frame(x) || !all(c("v", "w") %in% names(x))) {
stop("Input must be a data frame with columns 'v' and 'w'.")
}
if (W <= 0) {
stop("Knapsack capacity must be greater than 0.")
}
if (any(x$v < 0) || any(x$w < 0)) {
stop("Values and weights must be non-negative.")
}
n <- nrow(x)
best_value <- 0
best_combination <- NULL
# Create a list of all combinations to evaluate
combinations <- lapply(0:(2^n - 1), function(i) as.logical(intToBits(i)[1:n]))
if (parallel) {
# Detect the number of cores
num_cores <- detectCores()
# Use mclapply for parallel processing (Unix-like systems)
results <- mclapply(combinations, function(selected) {
total_weight <- sum(x$w[selected])
total_value <- sum(x$v[selected])
if (total_weight <= W) {
return(total_value)
} else {
return(0)
}
}, mc.cores = num_cores)
# Find the best value and corresponding combination
best_value <- max(unlist(results))
best_combination <- which(combinations[[which.max(unlist(results))]])
} else {
# Sequential processing
for (selected in combinations) {
total_weight <- sum(x$w[selected])
total_value <- sum(x$v[selected])
if (total_weight <= W && total_value > best_value) {
best_value <- total_value
best_combination <- which(selected)
}
}
}
return(list(value = best_value, elements = best_combination))
}
# 测试并行化的效果
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 12  # 使用较小的 n 以便于测试
knapsack_objects <- data.frame(
w = sample(1:4000, size = n, replace = TRUE),
v = runif(n = n, 0, 10000)
)
# 测试函数
system.time({
result <- brute_force_knapsack(x = knapsack_objects, W = 2000, parallel = TRUE)
})
print(result$value)
print(result$elements)
#' Solve the Knapsack Problem using Brute Force
#'
#' This function solves the knapsack problem using brute-force search.
#'
#' @param x A data frame with two columns: \code{v} for values and \code{w} for weights.
#' @param W A positive numeric value representing the maximum weight capacity of the knapsack.
#'
#' @return A list with two elements:
#'   \item{value}{The maximum total value of the knapsack.}
#'   \item{elements}{The indices of the items in \code{x} that make up the optimal solution.}
#'
#' @export
brute_force_knapsack <- function(x, W) {
if (!is.data.frame(x) || !all(c("v", "w") %in% names(x))) {
stop("Input must be a data frame with columns 'v' and 'w'.")
}
if (W <= 0) {
stop("Knapsack capacity must be greater than 0.")
}
if (any(x$v < 0) || any(x$w < 0)) {
stop("Values and weights must be non-negative.")
}
n <- nrow(x)
best_value <- 0
best_combination <- NULL
# Brute-force search: Enumerate all possible combinations (2^n)
for (i in 0:(2^n - 1)) {
selected <- as.logical(intToBits(i)[1:n])
total_weight <- sum(x$w[selected])
total_value <- sum(x$v[selected])
if (total_weight <= W && total_value > best_value) {
best_value <- total_value
best_combination <- which(selected)
}
}
return(list(value = best_value, elements = best_combination))
}
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
knapsack_objects <-
data.frame(
w=sample(1:4000, size = n, replace = TRUE),
v=runif(n = n, 0, 10000)
)
brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000)
system.time({
brute_force_knapsack(x = knapsack_objects[1:12,], W = 2000)
})
devtools::load_all(".")
rm(list = c("brute_force_knapsack", "dynamic_knapsack", "greedy_knapsack"))
devtools::load_all(".")
devtools::document()
devtools::build()
devtools::reload()
